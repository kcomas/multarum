Multarum

A dynamic apl/lisp language influenced by k
Operator Precedence is none
Collections are ref counted and passed by reference
All vars and operators must be ascii, strings are utf8

Atom types are denoted as negative numbers
While collection of atoms types are positive
0 denotes mixed vec

Pass by reference
Operators are in place
Comparisons are deep

Data Types:
0 Vec () internally it is always 0, calculated when you get the type
-1 Bool 8bit
-2 Int 64bit 0-9
-3 Float 64bit Int.Int
-4 Char 32bit utf8
4 String multi byte utf8
-5 File Descriptor
-6 Function
-7 Projection (Function[;])
-8 Module
-9 Error
-10 Thread
11 Dict (Stings)!()
12 Null (Returned from functions with no return)
100 Frame, Internal use only

Operators (Dyadic, Monadic)
() Grouping/Vec (Cannot have single element vec, have to enlist)
[] ,Access/Call
{ [] } Function [] are optional
// Comment
" " String/Char
` File
: Assign
:: Clone
= Equal
!= Not Equal
> Greater
<< Read/Write (0 stdin 1 stdout 2 stderr, -1 -2 not to add newline)
>= Greater Equal
< Less
<= Less Equal
! Zip, Not
!! Throw Error
& And/Min, Head
| Or/Max, Tail
, Concat, Enlist
' Map, Unzip/Debugger
@ Filter/Regex, Type
? ,Call w Catch, Cast (casting ref counted types to ints converts them to a pointer id)
^ Reduce, Length/Stat
+ Addition, Import
- Subtraction, Negate
* Multiplication, Dir List
/ Division, Reverse
% Remainder
$ ,Call Self, System
_ Delete At, Pop/File Delete
# Slice/Sort (stable)/Take, Rand
<> Split At
>< Join With
\ Built in (\cos)
. Global Set, Global Get
.. Apply
~ Thead Init, Join Thead
; End Statement

Control Flow
?{cond;expr;condn;exprn;default}

Implementation

1. Tokenize

Load File into single string
While stile has tokens, increase the start position and check if this current slice matches any tokens.
Once it does not match take the last match and return it
Once we go 50 chars of no matches return error

2. Parse

Grammar
statement: expression;?+
expression: primary OP expression | OP expression | primary
primary: NUMBER | VAR | STRING | CHAR | ( statement{2,} ) | { [VAR;]? statement;?+ };? | ? { statement;+ };? | ( statement )

Use recursive decent to convert tokens to an ast
Vars will be placed into a symbol table
Values will be given an id and placed into an array

3 Code Generation

Traverse ast and create static byte code
Each code will be 16bit

4. Bytecode Execution

Allocate a stack of vars and place frames on stack
